(cl:in-package :transform3)

(deftype matrix ()
  '(array double-float (4 4)))

(defun make-matrix ()
  (make-array '(4 4) :element-type 'double-float))

(defun copy-matrix (m &optional (copy (make-matrix)))
  (dotimes (i 16 copy)
    (setf (row-major-aref copy i)
	  (row-major-aref m i))))

(defun make-identity ()
  (make-array '(4 4) :element-type 'double-float
		     :initial-contents '((1.0d0 0.0d0 0.0d0 0.0d0)
					 (0.0d0 1.0d0 0.0d0 0.0d0)
					 (0.0d0 0.0d0 1.0d0 0.0d0)
					 (0.0d0 0.0d0 0.0d0 1.0d0))))

(defun multiply (a b &optional (product (make-matrix)))
  (dotimes (i 4 product)
    (dotimes (j 4)
      (let ((sum 0.0d0))
	(dotimes (k 4)
	  (incf sum (* (aref a i k) (aref b k j))))
	(setf (aref product i j) sum)))))

(defun transpose (m &optional (tr (make-matrix)))
  (dotimes (i 4 tr)
    (dotimes (j 4)
      (setf (aref tr i j)
	    (aref m j i)))))

(defun determinant (m)
  (- (+ (* (aref m 0 0)
	   (+ (* (aref m 1 1)
		 (- (* (aref m 2 2) (aref m 3 3))
		    (* (aref m 2 3) (aref m 3 2))))
	      (* (aref m 1 2)
		 (- (* (aref m 2 3) (aref m 3 1))
		    (* (aref m 2 1) (aref m 3 3))))
	      (* (aref m 1 3)
		 (- (* (aref m 2 1) (aref m 3 2))
		    (* (aref m 2 2) (aref m 3 1))))))
	(* (aref m 0 2)
	   (+ (* (aref m 1 0)
		 (- (* (aref m 2 1) (aref m 3 3))
		    (* (aref m 2 3) (aref m 3 1))))
	      (* (aref m 1 1)
		 (- (* (aref m 2 3) (aref m 3 0))
		    (* (aref m 2 0) (aref m 3 3))))
	      (* (aref m 1 3)
		 (- (* (aref m 2 0) (aref m 3 1))
		    (* (aref m 2 1) (aref m 3 0)))))))
     (+ (* (aref m 0 1)
	   (+ (* (aref m 1 0)
		 (- (* (aref m 2 2) (aref m 3 3))
		    (* (aref m 2 3) (aref m 3 2))))
	      (* (aref m 1 2)
		 (- (* (aref m 2 3) (aref m 3 0))
		    (* (aref m 2 0) (aref m 3 3))))
	      (* (aref m 1 3)
		 (- (* (aref m 2 0) (aref m 3 1))	
	    (* (aref m 2 1) (aref m 3 0))))))
	(* (aref m 0 3)
	   (+ (* (aref m 1 0)
		 (- (* (aref m 2 1) (aref m 3 2))
		    (* (aref m 2 2) (aref m 3 1))))
	      (* (aref m 1 1)
		 (- (* (aref m 2 2) (aref m 3 0))
		    (* (aref m 2 0) (aref m 3 2))))
	      (* (aref m 1 2)
		 (- (* (aref m 2 0) (aref m 3 1))
		    (* (aref m 2 1) (aref m 3 0)))))))))

(defun adjoint (m &optional (adj (make-matrix)))
  (macrolet ((calc (a a1 a2 a3 a4 b b1 b2 b3 b4 c c1 c2 c3 c4)
	       (flet ((calcrow (a b c d e)
			`(* (aref m ,@a) (- (* (aref m ,@b) (aref m ,@c))
					    (* (aref m ,@d) (aref m ,@e))))))
		 `(+ ,(calcrow a a1 a2 a3 a4)
		     ,(calcrow b b1 b2 b3 b4)
		     ,(calcrow c c1 c2 c3 c4)))))
    (setf (aref adj 0 0) (calc (1 1) (2 2) (3 3) (2 3) (3 2)
			       (2 1) (1 3) (3 2) (1 2) (3 3)
			       (3 1) (1 2) (2 3) (1 3) (2 2))
	  (aref adj 0 1) (calc (0 1) (2 3) (3 2) (2 2) (3 3)
			       (2 1) (0 2) (3 3) (0 3) (3 2)
			       (3 1) (0 3) (2 2) (0 2) (2 3))
	  (aref adj 0 2) (calc (0 1) (1 2) (3 3) (1 3) (3 2)
			       (1 1) (0 3) (3 2) (0 2) (3 3)
			       (3 1) (0 2) (1 3) (0 3) (1 2))
	  (aref adj 0 3) (calc (0 1) (1 3) (2 2) (1 2) (2 3)
			       (1 1) (0 2) (2 3) (0 3) (2 2)
			       (2 1) (0 3) (1 2) (0 2) (1 3))
	  (aref adj 1 0) (calc (1 0) (2 3) (3 2) (2 2) (3 3)
			       (2 0) (1 2) (3 3) (1 3) (3 2)
			       (3 0) (1 3) (2 2) (1 2) (2 3))
	  (aref adj 1 1) (calc (0 0) (2 2) (3 3) (2 3) (3 2)
			       (2 0) (0 3) (3 2) (0 2) (3 3)
			       (3 0) (0 2) (2 3) (0 3) (2 2))
	  (aref adj 1 2) (calc (0 0) (1 3) (3 2) (1 2) (3 3)
			       (1 0) (0 2) (3 3) (0 3) (3 2)
			       (3 0) (0 3) (1 2) (0 2) (1 3))
	  (aref adj 1 3) (calc (0 0) (1 2) (2 3) (1 3) (2 2)
			       (1 0) (0 3) (2 2) (0 2) (2 3)
			       (2 0) (0 2) (1 3) (0 3) (1 2))
	  (aref adj 2 0) (calc (1 0) (2 1) (3 3) (2 3) (3 1)
			       (2 0) (1 3) (3 1) (1 1) (3 3)
			       (3 0) (1 1) (2 3) (1 3) (2 1))
	  (aref adj 2 1) (calc (0 0) (2 3) (3 1) (2 1) (3 3)
			       (2 0) (0 1) (3 3) (0 3) (3 1)
			       (3 0) (0 3) (2 1) (0 1) (2 3))
	  (aref adj 2 2) (calc (0 0) (1 1) (3 3) (1 3) (3 1)
			       (1 0) (0 3) (3 1) (0 1) (3 3)
			       (3 0) (0 1) (1 3) (0 3) (1 1))
	  (aref adj 2 3) (calc (0 0) (1 3) (2 1) (1 1) (2 3)
			       (1 0) (0 1) (2 3) (0 3) (2 1)
			       (2 0) (0 3) (1 1) (0 1) (1 3))
	  (aref adj 3 0) (calc (1 0) (2 2) (3 1) (2 1) (3 2)
			       (2 0) (1 1) (3 2) (1 2) (3 1)
			       (3 0) (1 2) (2 1) (1 1) (2 2))
	  (aref adj 3 1) (calc (0 0) (2 1) (3 2) (2 2) (3 1)
			       (2 0) (0 2) (3 1) (0 1) (3 2)
			       (3 0) (0 1) (2 2) (0 2) (2 1))
	  (aref adj 3 2) (calc (0 0) (1 2) (3 1) (1 1) (3 2)
			       (1 0) (0 1) (3 2) (0 2) (3 1)
			       (3 0) (0 2) (1 1) (0 1) (1 2))
	  (aref adj 3 3) (calc (0 0) (1 1) (2 2) (1 2) (2 1)
			       (1 0) (0 2) (2 1) (0 1) (2 2)
			       (2 0) (0 1) (1 2) (0 2) (1 1)))
    adj))

(defun inverse (m &optional (inv (make-matrix)))
  (let ((d (determinant m)))
    (unless (zerop d)
      (adjoint m inv)
      (dotimes (i 4 inv)
	(dotimes (j 4)
	  (setf (aref inv i j)
		(* (aref inv i j) (/ 1.0 d))))))))

(defmacro column-major-write (i place matrix &key (float nil))
  (let* ((r (gensym))
	 (c (gensym))
	 (getform `(aref ,matrix ,r ,c)))
    `(dotimes (,r 4)
       (dotimes (,c 4)
	 (let ((,i (+ ,r (* 4 ,c))))
	   (setf ,place ,(if float
			     `(coerce ,getform 'single-float)
			     getform)))))))

(defmacro row-major-write (i place matrix &key (float nil))
  (let ((getform `(row-major-aref ,matrix ,i)))
    `(dotimes (,i 16)
       (setf ,place ,(if float
			 `(coerce ,getform 'single-float)
			 getform)))))
